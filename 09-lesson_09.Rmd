# Geometric operations with rasters {#geometric-operations-with-rasters}

```{r, include=FALSE}
knitr::opts_chunk$set(fig.align = 'center', collapse = TRUE, R.options = list(width = 80))
```

## Aims

* We will make changes in the geometric component of rasters - 
    * Mosaic
    * Clip
    * Aggregation / Disaggregation
    * Resampling and reprojection
* And create new rasters based on the relation between neighboring cells - 
    * Topographic calculations
    * Filtering
    * Segmentation

## Geometric component of rasters

* In the next few examples, we will process a **Digital Elevation Model (DEM)** raster of **Haifa**, by - 
    * Mosaicking
    * Cropping 
    * Reprojecting
* **Haifa** is located in the following coordinates, which we get from a GeoJSON file named `haifa.geojson` - 

```{r}
library(sf)

haifa = st_read("data/haifa.geojson", stringsAsFactors = FALSE)
```

```{r}
st_coordinates(haifa)
```

* We start with two $5\times5$ degree tiles of elevation data from the **Shuttle Radar Topography Mission** (SRTM) dataset 
* The tiles are included as two `.tif` **files** in the course materials  - 

```{r}
library(stars)

dem1 = read_stars("data/srtm_43_06.tif")
dem2 = read_stars("data/srtm_44_06.tif")
```

```{r, echo=FALSE, fig.width=7.3, fig.height=4.5, out.width="100%", fig.cap="Two elevation tiles from the SRTM dataset"}
plot(dem1)
plot(dem2)
```

* The tiles have the same **resolution** and aligned **extents** - 

```{r}
st_bbox(dem1)
```

```{r}
st_bbox(dem2)
```

* Rasters can be **mosaicked** using either the `merge` or the `mosaic` function
* The difference between them is in handling of **overlapping** cells - 
    * `merge` assigns the value from the **first** raster
    * `mosaic` calculates the value based on **all** layers, using the specified function (e.g. `mean`)
* In our case the tiles **do not overlap**, so it does not matter which function we choose - 

```{r}
dem = c(dem1, dem2, along = "x")
dem = st_set_crs(dem, 4326)
```

* Plot - 

```{r, fig.width=8, fig.height=5.4, out.width="100%", fig.cap="Merged raster"}
plot(dem, reset = FALSE)
plot(st_geometry(haifa), col = "red", pch = 16, add = TRUE)
```

## Creating `Extent` objects

* The `crop` function can **crop** a raster given - 
    * The input raster
    * An `Extent` object
* An `Extent` object specifies the coordinates of a **bounding box**
* It can be **created** with the `extent` function - 

```{r}
st_bbox(haifa)
```

* Adding a numeric value to an `Extent` object **increases** its size both vertically and horizontally, while keeping the **rectangular** shape
* For example, adding `0.25` to a **"point" extent** creates an $0.25\times0.25$ extent centered around that point - 

```{r}
haifa_ext = st_buffer(haifa, 0.25, endCapStyle = "SQUARE")
haifa_ext
```

* Plot - 

```{r, fig.width=8, fig.height=5.4, out.width="100%", fig.cap="An $0.25\\times0.25$ degrees \\texttt{Extent} object"}
plot(dem, reset = FALSE)
plot(st_geometry(haifa_ext), border = "red", add = TRUE)
```

## Cropping a raster with an `Extent` object

* The `crop` function **cuts** out a **rectangular** subset of a raster based on an `Extent` - 

```{r}
dem = dem[haifa_ext]
```

* Plot - 

```{r, fig.width=5.5, fig.height=6, out.width="62%", fig.cap="Cropped raster"}
plot(dem)
```

```{r, echo=FALSE, fig.cap="Cropping a raster", out.width="100%"}
knitr::include_graphics("images/lesson_09_crop.svg")
```

http://rpubs.com/etiennebr/visualraster

## Raster resampling

* Raster **resampling** is the process of transferring raster values from the original grid to a new grid

```{r, echo=FALSE, fig.cap="Raster resampling", out.width="80%"}
knitr::include_graphics("images/lesson_09_raster_resampling.png")
```

https://www.safe.com/transformers/raster-resampler/

* To demonstrate resampling, we will recreate the `ndvi`, `l_rec` and `r` rasters from **Lesson 06** - 

```{r}
l = read_stars("data/landsat_04_10_2000.tif")
ndvi = (l[,,,4] - l[,,,3]) / (l[,,,4] + l[,,,3])
ndvi = ndvi[,,,1,drop=TRUE]
names(ndvi) = "NDVI"
l_rec = ndvi
l_rec[l_rec < 0.2] = 0
l_rec[l_rec >= 0.2] = 1
```

```{r}
r = read_stars("data/modis_south.tif")
```

* In the next example we **resample** the `r` raster values into the `ndvi` grid - 

```{r}
plot(r[, , , 15], reset = FALSE)
plot(ndvi, add = TRUE, reset = FALSE)
plot(st_as_sfc(st_bbox(ndvi)), add = TRUE, border = "red")
```

* The `resample` function accepts three arguments - 
    * `x` - The raster we are **resampling**
    * `y` - The raster which defines the **new grid**
    * `method` - The resampling **method**, can be -
        * `"ngb"` - Nearest neighbor 
        * `"bilinear"` - Bilinear, i.e. weighted average of nearest 4 pixels (the default)

```{r}
r_resample_ngb = st_warp(r[, , , 15], ndvi, use_gdal = TRUE)
r_resample_bil = st_warp(r[, , , 15], ndvi, use_gdal = TRUE, method = "bilinear")
```

* We will **stack** the two layers -

```{r}
resample_results = c(
  r_resample_ngb, 
  r_resample_bil,
  along = 3
)
# names(resample_results) = c("Nearest", "Bilinear")
```

* Plot:

```{r}
plot(resample_results)
```

## Raster reprojection

* Raster **reprojection** is conceptually related to resampling; the difference in that in reprojection we resample into a grid which is in a **different CRS**
* The `projectRaster` function does raster reprojection -
    * `from` - The raster we want to **reproject**
    * `crs` - The **destination CRS**
    * `method` - The resampling **method**, can be either `"ngb"` or `"bilinear"`
    * `res` - The new grid **resolution** (optional)
* Another option is to specify - 
    * `from` - The raster we want to **reproject**
    * `to` - The raster which defines the **destination grid**

* For example - 

```{r, include=FALSE}
dem_old = dem
```

```{r}
dem = st_warp(src = dem, crs = 32636, method = "near", cellsize = 90)
```

* Plot - 

```{r, echo=FALSE, fig.width=8.18, fig.height=5, out.width="100%", fig.cap="Reprojection result"}
plot(dem_old)
plot(dem)
```

## Calculations based on neighboring cells

* Calculations based on **neighboring cells** include - 
    * **"Moving window"** calculations - Transformation of raster values using the values from a neighborhood surrounding each pixel (e.g. focal filter, topographic indices)

```{r, echo=FALSE, fig.cap="Focal filter", out.width="70%"}
knitr::include_graphics("images/lesson_09_focal_example.png")
```

http://courses.washington.edu/gis250/lessons/raster_analysis1/index.html

* Calculations based on **neighboring cells** include - 
    * **Segmentation** - Assignment of connected pixels with same (or similar) values into unique segments

```{r, echo=FALSE, fig.cap="Segmentation", out.width="70%"}
knitr::include_graphics("images/lesson_09_segmentation_example.jpg")
```

https://grass.osgeo.org/grass74/manuals/i.segment.html

## Focal filters

```{r, echo=FALSE, fig.cap="Focal filtering", out.width="90%"}
knitr::include_graphics("images/lesson_09_focal.svg")
```

http://rpubs.com/etiennebr/visualraster

* The `focal` function applies a **focal filter** ("moving window"), given - 
    * `x` - The input **raster**
    * `w` - A `matrix` which defines the **neighborhood size** and the **weights**
    * `fun` - The applied **function** (default is `sum`)
* The `w` matrix needs to have an **odd** number of rows and columns (such as $3\times3$, $7\times5$, etc.) because its **central cell** defines the focal window center
* The `w` matrix values determine the **weights**; raster values within the window are first **multiplied** by the weights in `w`, then **passed** to the function `fun`

* For example, the following **matrix** defines a $3\times3$ window with weights of `1` (therefore, essentially no weighting)
* The central cell `[2,2]` is the focal window center

```{r}
matrix(1, nrow = 3, ncol = 3)
```

* Question: how can we define a non-symmetric neighborhood, such as $2\times2$, even though matrix `w` can't have an even number of rows and columns?

* There are various types of filters for different needs, such as -
    * **Low Pass** filter - Smoothing, reducing noise, through averaging
    * **High Pass** filter - Expresses the deviation of the central cell value from the local average

```{r, echo=FALSE, fig.cap="Example of filters (Low pass and High pass)", out.width="50%"}
knitr::include_graphics(c("images/lesson_09_filter_low_pass.png", "images/lesson_09_filter_high_pass.png"))
```

http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-filter-works.htm

* For example, the following expression applies a **Low Pass** filter with a focal window of $3\times3$ -

## Low pass filter

```{r}
get_neighbors = function(m, pos) {
  v = c(
    m[pos[1]-1, pos[2]-1],
    m[pos[1]-1, pos[2]  ],
    m[pos[1]-1, pos[2]+1],
    m[pos[1],   pos[2]-1],
    m[pos[1],   pos[2]+1],
    m[pos[1]+1, pos[2]-1],
    m[pos[1]+1, pos[2]  ],
    m[pos[1]+1, pos[2]+1]
  )
  return(v)
}

focal2 = function(r, fun) {
  template = r
  input = template[[1]]
  output = input
  output[] = NA
  for(i in 2:(nrow(input) - 1)) {
    for(j in 2:(ncol(input) - 1)) {
      v = get_neighbors(input, c(i, j))
      output[i, j] = fun(v)
    }
  }
  template[[1]] = output
  return(template)
}
```

```{r}
r_lowpass = focal2(r[, , , 1, drop = TRUE], mean)
```

```{r}
plot(r_lowpass)
```

* Given a raster with `0` and `1` values (such as `l_rec`), we may want to convert all `0` cells neighboring to a `1` cell to become `1`
* This can be achieved with a **focal filter** and `max` - 

```{r}
l_rec_focal = focal2(l_rec, max)
```

* Plot - 

```{r, echo=FALSE, fig.cap='"Buffering" `1` values in a raster', fig.width=9.4, fig.height=5, out.width="100%"}
plot(l_rec_focal)
```

Note that our custom focal filter function is quite minimal, and can be improved in several ways:

* Dealing with `NA` values
* Dealing with the first/last rows and and columns

* When we apply a **Low Pass** filter more than once, consecutively, we get a higher degree of smoothing
* For example, the following code applies a $7\times7$ Low Pass filter on `l_rec` **10 times** - 

```{r}
# l_rec_lp = l_rec
# for(i in 1:10) {
#   l_rec_lp = raster_focal(
#     x = l_rec_lp,
#     w = matrix(1, nrow = 7, ncol = 7),
#     fun = mean
#   )
# }
```

* Plot - 

```{r, echo=FALSE, fig.width=9.4, fig.height=5, out.width="100%", fig.cap="Low Pass filter applied 10 times"}
# plot(l_rec)
# plot(l_rec_lp)
```

* Question 1: why does the outer boundary now has `NA`s?
* Question 2: why does the values range no longer includes `1`?


## Segmentation

```{r, echo=FALSE, fig.cap="Segmentation with the `clump` function", out.width="100%"}
knitr::include_graphics("images/lesson_09_clump.svg")
```

http://rpubs.com/etiennebr/visualraster

* The `clump` function detects **segments** of **connected** pixels with **any value** other than `0` or `NA`, returning a raster where each segment has a **unique ID**
* Cells with `0` or `NA` are treated as **background**, they are not part of any segment
* Using `gaps=FALSE` "forces" the segment IDs to be **consecutive** integers `1`, `2`, ..., `n` (where `n` is the number of segments)
* Note: the `igraph` package needs to be installed for the `clump` function to work

* For example - 

```{r}
pol = st_as_sf(l_rec_focal, merge = TRUE)
pol = pol[pol$NDVI == 1, ]
```

* Question 1: What is the exact number of segments in `l_rec_focal_clump`?
* Question 2: If we ran the `clump` function on `l_rec` instead of `l_rec_focal`, do you think the number of segments would be higher or lower?

* Plot - 

```{r, fig.width=6.5, fig.height=7.3, out.width="62%", fig.cap="Segments detected with `raster_clump`"}
plot(pol)
```














